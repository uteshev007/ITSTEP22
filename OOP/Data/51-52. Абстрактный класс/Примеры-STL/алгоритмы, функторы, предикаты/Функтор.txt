#include <algorithm>
#include <iostream>
#include <iterator>
#include <list>
using namespace std;
class LC { public: LC() { setlocale(LC_ALL, "Rus"); } ~LC() { cin.get(); cin.get(); } }l;

/* Функциональный объект, содержащий два поля:
 1. для хранения значения приращения (delta)
 2. для текущего значения генерируемого числа (current) */
class addNumberFrom
{
  int delta;
  int current;
public:
  /* Конструктор класса инициализирует значение приращения и
   текущее значение. Последнее может быть опущено, и тогда
   оно будет считаться равным 0 */
  addNumberFrom(int number, int from = 0) :
    delta(number), current(from) {}

  /* Основа функтора - перегруженный оператор вызова функции -
   прибавляет значение приращения к текущему генерируемому числу */
  int operator()() {
    return current += delta;
  }
};
//Вывод заголовка для таблицы умножения.
void main() {
  cout << "TABLE:" << "\n\n";
  cout << "----------" << "\n\n";
  for (int i = 1; i <= 10; i++) {
    //Cоздание контейнера-списка.
    list<int> l(10);
    /* Вызов алгоритма generate_n().
      Естественно, сам он не может ничего генерировать, однако
      последовательно перебирает значения, диапазон которых
      задан начальным итератором и количеством элементов списка.
      Для записи числа в каждое значение вызывается функция,
      на которую ссылается третий параметр:
    */

    // Код выполняющий аналогичные действия,
    //  что и функтор addNumberFrom()
    int j = i;
    generate_n( l.begin(), l.size(),
      [i, &j]() { int k = j; j += i; return k; } );

    //generate_n(l.begin(), l.size(), addNumberFrom(i));
    /* Но мы вместо функции подставляем перегруженный оператор
      вызова функции - объект addNumberFrom.
      Если вызов происходит впервые, то вызывается конструктор
      объекта. Он инициализирует поле delta значением переменной i,
      а поле current значением по умолчанию второго параметра
      конструктора, т. е. 0.
      Таким образом, контейнер-список заполняется произведениями
      числа в переменной i и множителями от 1 до 10.
      В алгоритме generate_n() используется метод size(), который
      возвращает количество элементов в списке.
      Если имеются начальный и конечные итераторы, тогда лучше
      воспользоваться алгоритмом generate().
    */

    /* Собственно показ числа из контейнера-списка */
    copy(l.begin(), l.end(), ostream_iterator<int>(cout, "\t"));
    cout << endl;
  }
}
