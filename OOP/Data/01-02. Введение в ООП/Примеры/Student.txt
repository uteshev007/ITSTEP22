// warning C4996: 'strcpy': This function or variable may be unsafe. Consider using strcpy_s instead.
// To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
#define _CRT_SECURE_NO_WARNINGS // disable deprecation
#include <iostream>
using namespace std;
#pragma warning(disable:4996) // отключение warning C4996

/*
Классы в С++ - это абстракция описывающая методы, свойства, ещё не существующих объектов.
Объекты - конкретное представление абстракции, имеющее свои свойства и методы.
Экземпляры класса - созданные объекты на основе одного класса.
Эти объекты могут иметь различное поведение, свойства, но все равно будут являться объектами одного класса.

В ООП существует три основных принципа построения классов:

1.Инкапсуляция - это свойство, позволяющее объединить в классе и данные, и методы,
                  работающие с ними и скрыть детали реализации от пользователя.
2.Наследование - это свойство, позволяющее создать новый класс-потомок на основе уже существующего,
                   при этом все характеристики класса родителя присваиваются классу-потомку.
3.Полиморфизм - свойство классов, позволяющее использовать объекты классов с одинаковым интерфейсом
                 без информации о типе и внутренней структуре объекта, и соответственно реализовать
                 различную реакцию класса одноименными интерфейсами (функциями-членами класса) на разного
                 рода, типа входных данных.
*/


/*
Модификаторы доступа:
public    - открытые, доступные всем за пределами класса члены класса.
private   - частные, собственные члены класса. Недоступны за пределами класса.
              Доступ открыт самому классу (т.е. функциям-членам данного класса)
              и друзьям (friend) данного класса, как функциям, так и классам.
protected - закрытые члены класса. Недоступны за пределами класса.
              Доступ открыт классам, производным от данного
*/
class Student
{ // по умолчанию доступ к членам класса - private
  char Name[30]; // закрытый член класса
private:  // принудительное указание спецификатора доступа - private
          // private - частные, собственные члены класса. Недоступны за пределами класса.
  int Age;  // закрытый член класса

public:   // public - открытые, доступные за пределами класса члены класса.
  int Kurs; // открытый член класса

  // Специальные методы класса, функции класса
  // *) Конструктор по умолчанию - конструктор без параметров. Не перегружается
  //    Конструктор для любого объекта должен вызываться только ОДИН РАЗ!
  Student() : Name(""), Age(0), Kurs(0) // - делегирование конструкторов членов класса
  { // делегирование конструкторов членов класса - один из вариантов первичной инициализации членов класса
    // другой вариант первичной инициализации членов класса - их иницализация в теле конструктора класса
    cout << "Вызов конструктора Student::Student()" << endl;
    Name[0] = '\0';
    Age = 0;
    Kurs = 0;
  }

  // **) Конструкторы с параметрами.
  //     Перегружается - возможна реализация нескольких конструкторов с параметрами
  Student(char * NewName) : Student() // - делегирование конструктора по умолчанию
  {
    cout << "Вызов конструктора Student::Student(char*)" << endl;
    //strcpy(Name, NewName);
    setName(NewName);
  }

  Student(int NewAge) : Student() //, Age(NewAge) - так нельзя - делегируется только один конструктор
  {                               // конструктор для любого объекта должен вызываться только ОДИН РАЗ!
    cout << "Вызов конструктора Student::Student(int)" << endl;
    SetAge(NewAge); // из конструкторов можно вызывать методы класса
  }

  Student(int NewAge, int NewKurs) : Age(NewAge), Kurs(NewKurs) // делегируется только один конструктор
  {
    cout << "Вызов конструктора Student::Student(int,int)" << endl;
    // другой вариант первичной инициализации членов класса - их иницализация в теле конструктора класса
    SetAge(NewAge); // из конструкторов можно вызывать методы класса
    setKurs(NewKurs);
  }

  Student(char * NewName, int NewAge, int NewKurs) : Age(NewAge), Kurs(NewKurs)
  {
    cout << "Вызов конструктора Student::Student(char*,int.int)" << endl;
    setName(NewName);
  }

  // **) Конструктор копирования - обязателен, когда в классе есть указатель и осуществляется
  //      динамическое выделение памяти
  Student(Student& st) : Age(st.Age), Kurs(st.Kurs) // делегирование конструкторов
  {
    cout << "Вызов конструктора копирования Student::Student(Student&)" << endl;
    // преобразование типа в стиле C++ - снятие спецификатора const
    setName(const_cast<char*>(st.getName()));
  }

  // **) Конструктор переноса - актуален, когда в классе есть указатель и осуществляется
  //      динамическое выделение памяти
  Student(Student&& st) : Student() // делегирование конструктора по умолчанию
  {
    cout << "Вызов конструктора переноса Student::Student(Student&&)" << endl;
  }

  // ***) Деструктор - специальный метод класса
  //    ОБЯЗАТЕЛЬНО без типа и без параметров. Не перегружается
  //    Вызывается один раз когда уничтожается экземпляр класса
  //    ОБЯЗАТЕЛЕН, когда в классе есть указатель и для него осуществляется
  //     динамическое выделение памяти
  ~Student()
  {
    cout << "Вызов деструктора Student::~Student()" << endl;
    // здесь освобождение ресурсов, которые мог выделять и использовать класс:
    //  *) динамически выделенная память - освобождение памяти: delete/delete[]/free()
    //  *) открытые файлы, системные дескрипторы - закрытие файлов, дескрипторов
  }

  // Другие произвольные, неспециальные методы класса
  //  Аксессоры класса:
  //   set-функции  - модификаторы, сеттеры;
  //   get-функции  - инспекторы, геттеры;
  // Открытый, публичный метод класса для установки значения члена класса Age
  //  модификатор для Age
  void SetAge(int NewAge){
    Age = NewAge;
  }
  //  инспектор Age
  int getAge() const { // const - константный метод класса, ему запрещено менять значения членов класса
    return Age;
  }

  // модификатор для переменной класса Kurs
  void setKurs(int NewKurs){
    Kurs = NewKurs;
  }
  //  инспектор перемнной класса Kurs
  int getKurs() const { // const - константный метод класса, ему запрещено менять значения членов класса
    return Kurs;
  }

  // модификатор для переменной класса Name
  void setName(char * NewName);

  //  инспектор перемнной класса name
  const char * getName() const { // константный метод
    return Name;
  }
  //char * getName() { // не константный метод
  //  return Name;
  //}


  // Другие простые методы класса
  void Show();

protected: // protected - закрытые члены класса. Недоступны за пределами класса.
  // закрытые методы класса, недоступны за пределеами класса
  void printAge() {
    cout << Age;
  }
  void showKurs() const {
    cout << Kurs;
  }
};

// реализация методов (ф-ций) класса за пределами тела класса

// модификатор для переменной класса Name
inline void Student::setName(char * NewName) // Встроенный inline-метод
{
  strcpy(Name, NewName);
}

// Печать элементов класса
void Student::Show()
{
  cout << "Name: " << getName() << endl;
 
  cout << "Age:  ";
  printAge();
  cout << endl;
  
  cout << "Kurs: ";
  showKurs();
  cout << endl;
}

int main()
{
  //setlocale(LC_ALL, "Russian");
  system("chcp 1251 > nul");
  Student stud1; // вызывается конструктор по умолчанию Student::Student()
  Student stud2("Name2"); // Student::Student(char * NewName);
  Student stud3(21);      // Student::Student(int NewAge);

  stud1.setName("Vasya");
  stud1.SetAge(18);
  stud1.setKurs(1);
  cout << endl << "** Student stud1;" << endl;
  stud1.Show();

  // динамическое создание экземпляров объекта Student
  Student *pstud4 = new Student(20,3); // Student::Student(int NewAge, int NewKurs);
  Student *pstud5 = new Student("Sultan", 22, 4); // Student::Student(char * NewName, int NewAge, int NewKurs);

  // Создание копии с помощью конструктора копирования
  Student stud6(stud1); // Student::Student(Student&&);
  cout << endl << "** Student stud6;" << endl;
  stud6.Show();

  stud2.SetAge(20);
  stud2.setKurs(2);
  cout << endl << "** Student stud2;" << endl;
  stud2.Show();

  stud3.setName("Indira");
  stud3.setKurs(4);

  pstud4->setName("Vova");
  cout << endl << "** Student pstud4;" << endl;
  pstud4->Show();


  cout << endl << "** Student stud3;" << endl;
  stud3.Show();

  cout << endl << "** Student pstud5;" << endl;
  pstud5->Show();

  cout << endl;
  // освобождение памяти 
  delete pstud4;
  delete pstud5;
  cout << endl;

  // динамическое создание массива объектов типа Student
  Student *pst = new Student[3]{stud1, stud2, stud3}; // инициализация списком

  cout << endl << "** Student pst[0];" << endl;
  pst[0].Show();
  cout << endl << "** Student pst[1];" << endl;
  pst[1].Show();
  cout << endl << "** Student pst[2];" << endl;
  pst[2].Show();

  cout << endl;
  // освобождение памяти 
  delete[]pst;

  cin.get(); cin.get();
  return 0;
}
