/*
* 
* Пример работы с мышкой в программе
*  в данном коде пример опроса и обработки состояния устройства мышь
*  в функции меню
* Для проверки кода следует этот код подключить к проекту вместо предыдущего
*  варианта функции меню
* Также следует обновить коды файлов Win10.cpp и Win10.h
* В них добавлены функции опроса состояний кнопок манипулятора мышь и
*  запроса текущей координаты указателя мыши
* В кодах присутствуют соответствующие коментарии при обращении к ф-циям
*  работы с мышью
* 
* Чтобы программа адекватно реагировала на события от мыши, следует в свойствах
*  консольного окна в первой вкладке "Настройки" снять галочку "Выделение мышью"
* 
*/

//
// Menu.cpp
//
#include <iostream>
#include "Win10.h"
using namespace std;


// Ф-ция вывода и управления интерактивным меню
int Menu( const char * Items[], int cntItems,
          int yRow, int xCol, int Select )
{
  // цвета для меню
  // цвет активного пункта меню
  int clSelBkgr = COLOR::blue;          // цвет фона
  int clSelSym  = COLOR::light_yellow;  // цвет символа
  // цвет неактивных пунктов
  int clDefBkgr = COLOR::green; // цвет фона
  int clDefSym  = COLOR::white; // цвет символа

  // чтобы знать точные диапазоны координат пунктов меню,
  //  нужно определить размеры каждой строки меню
  int * pItemLen = new int[cntItems]; // массив длин строк пунктов меню
  int ItemMaxLen = 0; // максимальная длина строки
                      //   тут можно задать 0 для ItemMaxLen, т.к. длины строк не могут быть меньше 0
  for(int i = 0; i < cntItems; i++) {
    pItemLen[i] = strlen( Items[i] ); // длина строки i-ого пункта меню
    ItemMaxLen = (ItemMaxLen < pItemLen[i]) ? pItemLen[i] : ItemMaxLen; // макс. длина
  }

  // проверка, чтобы переменная Select не выходила за пределы пунктов меню
  if(Select < 0 || Select >= cntItems) { Select = 0; }

  int SelectPrev = -1; // предыдущей индекс выбранного пункта меню курсором мыши
                       //  нужен, чтобы курсор мыши находясь над меню не блокировал
                       //  выбор клавишами управления курсора

  int mRow, mCol; // текущие координаты курсора мышки
  int mRowPrev = -1, mColPrev = -1; // предыдущие координаты курсора мышки перед ее перемещением

  while(true)
  {
    //
    // 1) код слежения за перемещением курсора мышки
    //
    GetMouseCoord( mRow, mCol ); // получить консольную координату курсора мышки
    // проверяем - сдвинулась ли мышка
    if(mRow != mRowPrev || mCol != mColPrev) {
      // если курсор мыши сместился (изменил координтаты)
      // проверяем попадают ли координаты мыши в область меню
      if(mRow >= yRow && mRow < yRow + cntItems) {
        int index = mRow - yRow; // номер строки над которой курсор мыши
        // проверяем попадают ли гориз. координаты мыши в диапазон строки меню под индексом в index
        if(mCol >= xCol && mCol < xCol + pItemLen[index]) { // можно ориентироваться точно по выбранной строке в меню
          //if(mCol >= xCol && mCol < xCol + ItemMaxLen) { // или можно ориентироваться по самой широкой строке в меню
          Select = index; // выбираем пункт под курсором мыши
        }
      }
      //SetPos( 0, 10 ); printf( "%3d - %3d       ", mRow, mCol ); // для мониторинга на экране
      // запоминаем последние координаты мышки
      mRowPrev = mRow;
      mColPrev = mCol;
    }

    //
    // 2) проверка нажатия кнопок мыши
    //
    //if(isLButtonDown() || isRButtonDown() || isMButtonDown()) { // можно проверять все кнопки мышки
    //
    // проверка нажатия левой кнопки мыши
    if(isLButtonDown()) {
      //int mRow, mCol;
      GetMouseCoord( mRow, mCol ); // получить консольную координату курсора мышки
      // проверяем попадают ли координаты мыши в область меню
      if(mRow >= yRow && mRow < yRow + cntItems) {
        int index = mRow - yRow; // номер строки над которой курсор мыши
        // проверяем попадают ли гориз. координаты мыши в диапазон строки меню под индексом в index
        if(mCol >= xCol && mCol < xCol + pItemLen[index]) {
          Select = index; // выбираем пункт под курсором мыши
          return Select;  // возвращаем индекс выбранного пункта меню
        }
      }
    }

    // 3) вывод пунктов меню на экран
    if(Select != SelectPrev) { // что не мерцало из-за постоянной прорисовки меню
      for(int i = 0; i < cntItems; i++) {
        SetPos( yRow + i, xCol ); // экранная позиция для i-го пункта меню
        if(i == Select) { SetColor( clSelBkgr, clSelSym ); } // активный пункт
        else { SetColor( clDefBkgr, clDefSym ); } // некативный пункт меню
        cout << Items[i];
      }
      // Восстановление цвета консоли для последующего вывода
      SetColor( COLOR::black, COLOR::white ); // SetColor(7);
      SelectPrev = Select;
    }

    // 4) обработка нажатий клавиш
    int key = -1; // для клавиатуры
    //
    // тут нужен вызов ф-ции _kbhit(), т.к. меню стало динамичным и управляется
    //  мышкой независимо от клавиатуры
    //
    if(_kbhit()) {
      key = _getch(); // ожидание нажатия клавиши на клавиатуре
    }
    // тут все без изменений
    switch(key)
    {
      case UP: // вверх
      case LEFT:
      case 'w': case 'W':
        if(Select > 0) { Select--; }
        else { Select = cntItems - 1; }
        break;

      case DOWN: // вниз
      case RIGHT:
      case 's': case 'S':
        if(Select < cntItems-1) { Select++; }
        else { Select = 0; }
        break;

      case ESC: // отказ от выбора
        return -1; // возвращаем недействительный индекс

      case ENTER: // выбор пункта меню 
        return Select; // возвращаем индекс активного пункта меню
    }
    //
    // добавляем вызов Sleep(), чтобы не нагружать процессор на 100%
    // передаем нулевое значение милисекунд - отдаем системе свой квант времени,
    //  чтобы система сама определила, когда наш рабочий поток должен будет проснуться
    //
    Sleep( 0 );

  } // while(true)

} // int Menu();

